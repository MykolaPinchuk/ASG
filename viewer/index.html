<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ASG Replay Viewer</title>
    <style>
      :root {
        --bg: #0b1020;
        --panel: #101a33;
        --text: #e8eefc;
        --muted: #9fb0d0;
        --p1: #4ea1ff;
        --p2: #ff5a73;
        --neutral: #8c97b2;
        --edge: rgba(232, 238, 252, 0.18);
        --border: rgba(232, 238, 252, 0.12);
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        background: var(--bg);
        color: var(--text);
      }
      header {
        padding: 12px 16px;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      header h1 {
        margin: 0;
        font-size: 14px;
        font-weight: 650;
        letter-spacing: 0.02em;
        white-space: nowrap;
      }
      #controls {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
      }
      #controls label {
        font-size: 12px;
        color: var(--muted);
        margin-right: 6px;
      }
      #controls select,
      #controls input[type="file"],
      #controls button {
        font-size: 12px;
        color: var(--text);
      }
      button {
        background: rgba(232, 238, 252, 0.06);
        border: 1px solid rgba(232, 238, 252, 0.16);
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.5;
        cursor: default;
      }
      #layout {
        height: calc(100% - 54px);
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 12px;
        padding: 12px;
        box-sizing: border-box;
      }
      #mapWrap {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
      }
      #dropHint {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-size: 13px;
        border: 2px dashed rgba(232, 238, 252, 0.18);
        margin: 10px;
        border-radius: 10px;
        background: rgba(11, 16, 32, 0.35);
        pointer-events: none;
      }
      #map {
        width: 100%;
        height: 100%;
        display: block;
      }
      #side {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        overflow: auto;
      }
      .block {
        margin-bottom: 12px;
      }
      .block h2 {
        margin: 0 0 6px 0;
        font-size: 12px;
        color: var(--muted);
        font-weight: 650;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }
      pre {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        font-size: 12px;
        line-height: 1.35;
      }
      .pill {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 12px;
        border: 1px solid rgba(232, 238, 252, 0.16);
        color: var(--muted);
        white-space: nowrap;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .row > * {
        flex: 0 0 auto;
      }
      .grow {
        flex: 1 1 auto;
        min-width: 260px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>ASG Replay Viewer</h1>
      <div id="controls">
        <input id="fileInput" type="file" accept="application/json" />
        <span class="pill" id="status">No replay loaded</span>

        <div class="row">
          <label for="viewMode">View</label>
          <select id="viewMode">
            <option value="Omni">Omni</option>
            <option value="P1">P1 POV</option>
            <option value="P2">P2 POV</option>
            <option value="Diff">Diff</option>
          </select>
        </div>

        <div class="row">
          <label for="timeMode">State</label>
          <select id="timeMode">
            <option value="after">After</option>
            <option value="before">Before</option>
          </select>
        </div>

        <div class="row">
          <button id="prevBtn" title="Left arrow">Prev</button>
          <button id="nextBtn" title="Right arrow">Next</button>
        </div>

        <div class="grow">
          <input id="turnSlider" type="range" min="0" max="0" value="0" step="1" style="width: 100%" />
          <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--muted)">
            <span id="startLabel">Start</span>
            <span id="turnLabel">—</span>
            <span id="endLabel">End</span>
          </div>
        </div>
      </div>
    </header>

    <div id="layout">
      <div id="mapWrap">
        <div id="dropHint">Drop a replay JSON here</div>
        <svg id="map" viewBox="0 0 800 600"></svg>
      </div>
      <div id="side">
        <div class="block">
          <h2>Turn</h2>
          <pre id="turnInfo">Load a replay JSON to begin.</pre>
        </div>
        <div class="block">
          <h2>Selected Node</h2>
          <pre id="nodeInfo">Click a node to inspect details.</pre>
        </div>
        <div class="block">
          <h2>Rationale</h2>
          <pre id="rationale">—</pre>
        </div>
        <div class="block">
          <h2>Actions</h2>
          <pre id="actions">—</pre>
        </div>
        <div class="block">
          <h2>Events</h2>
          <pre id="events">—</pre>
        </div>
      </div>
    </div>

    <script>
      /** @type {any | null} */
      let replay = null;
      /** @type {Record<string, any> | null} */
      let nodeEls = null;
      /** @type {Record<string, any> | null} */
      let nodePos = null;
      /** @type {string | null} */
      let selectedNodeId = null;

      const fileInput = document.getElementById("fileInput");
      const statusEl = document.getElementById("status");
      const slider = document.getElementById("turnSlider");
      const turnLabel = document.getElementById("turnLabel");
      const viewMode = document.getElementById("viewMode");
      const timeMode = document.getElementById("timeMode");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const dropHint = document.getElementById("dropHint");

      const turnInfo = document.getElementById("turnInfo");
      const nodeInfo = document.getElementById("nodeInfo");
      const rationale = document.getElementById("rationale");
      const actions = document.getElementById("actions");
      const events = document.getElementById("events");

      const svg = document.getElementById("map");

      function ownerColor(owner) {
        const css = getComputedStyle(document.documentElement);
        if (owner === "P1") return css.getPropertyValue("--p1");
        if (owner === "P2") return css.getPropertyValue("--p2");
        return css.getPropertyValue("--neutral");
      }

      function clearSvg() {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
      }

      function computeInitialState(scenario) {
        const nodes = {};
        for (const nodeDef of scenario.map.nodes) {
          nodes[nodeDef.id] = {
            id: nodeDef.id,
            x: nodeDef.x,
            y: nodeDef.y,
            owner: nodeDef.owner,
            supplyYield: nodeDef.supplyYield,
            forces: { P1: 0, P2: 0 },
          };
        }

        const nodeForces = (scenario.initialState && scenario.initialState.nodeForces) || {};
        for (const [nodeId, forces] of Object.entries(nodeForces)) {
          if (!nodes[nodeId]) continue;
          nodes[nodeId].forces.P1 = (forces && forces.P1) || 0;
          nodes[nodeId].forces.P2 = (forces && forces.P2) || 0;
        }

        const playerSupply = (scenario.initialState && scenario.initialState.playerSupply) || {};
        return {
          scenarioId: scenario.id,
          ply: 0,
          activePlayer: scenario.startingPlayer,
          supplies: { P1: playerSupply.P1 || 0, P2: playerSupply.P2 || 0 },
          nodes,
        };
      }

      function buildMap() {
        clearSvg();
        nodeEls = {};
        nodePos = {};

        const nodes = replay.scenario.map.nodes;
        const edges = replay.scenario.map.edges;

        const xs = nodes.map((n) => n.x);
        const ys = nodes.map((n) => n.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        const pad = 60;

        const w = 800;
        const h = 600;
        const spanX = Math.max(1, maxX - minX);
        const spanY = Math.max(1, maxY - minY);
        const scale = Math.min((w - 2 * pad) / spanX, (h - 2 * pad) / spanY);

        const pos = (x, y) => {
          const sx = pad + (x - minX) * scale;
          const sy = pad + (maxY - y) * scale;
          return { x: sx, y: sy };
        };

        for (const n of nodes) nodePos[n.id] = pos(n.x, n.y);

        for (const [a, b] of edges) {
          const pa = nodePos[a];
          const pb = nodePos[b];
          if (!pa || !pb) continue;

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", pa.x);
          line.setAttribute("y1", pa.y);
          line.setAttribute("x2", pb.x);
          line.setAttribute("y2", pb.y);
          line.setAttribute("stroke", getComputedStyle(document.documentElement).getPropertyValue("--edge"));
          line.setAttribute("stroke-width", "2");
          svg.appendChild(line);
        }

        for (const n of nodes) {
          const p = nodePos[n.id];
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

          const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          circle.setAttribute("cx", p.x);
          circle.setAttribute("cy", p.y);
          circle.setAttribute("r", "18");
          circle.setAttribute("fill", ownerColor(n.owner));
          circle.setAttribute("stroke", "rgba(232,238,252,0.25)");
          circle.setAttribute("stroke-width", "2");
          circle.style.cursor = "pointer";
          circle.addEventListener("click", () => {
            selectedNodeId = n.id;
            renderSelectedNode();
          });
          g.appendChild(circle);

          const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
          label.setAttribute("x", p.x);
          label.setAttribute("y", p.y - 24);
          label.setAttribute("text-anchor", "middle");
          label.setAttribute("fill", "rgba(232,238,252,0.85)");
          label.setAttribute("font-size", "11");
          label.textContent = n.id;
          g.appendChild(label);

          const forces = document.createElementNS("http://www.w3.org/2000/svg", "text");
          forces.setAttribute("x", p.x);
          forces.setAttribute("y", p.y + 5);
          forces.setAttribute("text-anchor", "middle");
          forces.setAttribute("fill", "rgba(11,16,32,0.95)");
          forces.setAttribute("font-size", "12");
          forces.setAttribute("font-weight", "750");
          forces.textContent = "0|0";
          g.appendChild(forces);

          const yieldText = document.createElementNS("http://www.w3.org/2000/svg", "text");
          yieldText.setAttribute("x", p.x);
          yieldText.setAttribute("y", p.y + 26);
          yieldText.setAttribute("text-anchor", "middle");
          yieldText.setAttribute("fill", "rgba(232,238,252,0.7)");
          yieldText.setAttribute("font-size", "11");
          yieldText.textContent = n.supplyYield > 0 ? `+${n.supplyYield}` : "";
          g.appendChild(yieldText);

          svg.appendChild(g);
          nodeEls[n.id] = { circle, forces, yieldText };
        }
      }

      function clampIndex(i) {
        if (!replay) return 0;
        return Math.max(0, Math.min(i, replay.turns.length));
      }

      function beforeStateForIndex(index) {
        if (!replay) return null;
        if (index <= 0) return computeInitialState(replay.scenario);
        return replay.turns[index - 1].stateAfter;
      }

      function afterStateForIndex(index) {
        if (!replay) return null;
        if (index < 0 || index >= replay.turns.length) return null;
        return replay.turns[index].stateAfter;
      }

      function getFrame(index) {
        if (!replay) return null;

        if (index === 0 && timeMode.value === "before") {
          const init = computeInitialState(replay.scenario);
          return { kind: "init", index, turn: replay.turns[0], state: init };
        }

        if (index <= 0) {
          const init = computeInitialState(replay.scenario);
          return { kind: "init", index: 0, turn: replay.turns[0], state: init };
        }

        const tIndex = index - 1;
        const turn = replay.turns[tIndex];
        if (!turn) return null;

        const vm = viewMode.value;
        const tm = timeMode.value;

        const beforeState = beforeStateForIndex(tIndex);
        const afterState = afterStateForIndex(tIndex);

        if (tm === "before") {
          if (vm === "P1") return { kind: "before", index: tIndex, turn, state: turn.observations.P1 };
          if (vm === "P2") return { kind: "before", index: tIndex, turn, state: turn.observations.P2 };
          // Omni/Diff "before" uses omniscient state-before (previous stateAfter / initial).
          return { kind: "before", index: tIndex, turn, state: beforeState };
        }

        // After: omniscient post-resolution state.
        return { kind: "after", index: tIndex, turn, state: afterState };
      }

      function updateButtons() {
        if (!replay) {
          prevBtn.disabled = true;
          nextBtn.disabled = true;
          return;
        }
        const idx = Number.parseInt(slider.value, 10);
        prevBtn.disabled = idx <= 0;
        nextBtn.disabled = idx >= replay.turns.length;
      }

      function renderSelectedNode() {
        if (!replay || !selectedNodeId) return;

        const sliderIndex = Number.parseInt(slider.value, 10) - 1;
        const turn = replay.turns[Math.max(0, sliderIndex)];
        const tm = timeMode.value;

        const beforeOmni = sliderIndex < 0 ? computeInitialState(replay.scenario) : beforeStateForIndex(sliderIndex);
        const afterOmni = sliderIndex < 0 ? null : afterStateForIndex(sliderIndex);

        const p1 = turn?.observations?.P1?.nodes?.[selectedNodeId];
        const p2 = turn?.observations?.P2?.nodes?.[selectedNodeId];
        const omni = tm === "before" ? beforeOmni?.nodes?.[selectedNodeId] : afterOmni?.nodes?.[selectedNodeId];

        function fmt(label, n) {
          if (!n) return `${label}: (missing)`;
          const f1 = n.forces?.P1 ?? "?";
          const f2 = n.forces?.P2 ?? "?";
          return `${label}: owner=${n.owner} forces=P1:${f1} P2:${f2} yield=${n.supplyYield}`;
        }

        nodeInfo.textContent = [
          `node: ${selectedNodeId}`,
          fmt("P1 sees", p1),
          fmt("P2 sees", p2),
          fmt("Omni", omni),
        ].join("\n");
      }

      function render() {
        const sliderIndex = Number.parseInt(slider.value, 10);
        const frame = getFrame(sliderIndex);
        updateButtons();

        if (!frame || !frame.state || !nodeEls) return;

        const nodes = frame.state.nodes;
        for (const [id, el] of Object.entries(nodeEls)) {
          const n = nodes[id];
          if (!n) continue;
          el.circle.setAttribute("fill", ownerColor(n.owner));
          const p1 = n.forces?.P1 ?? 0;
          const p2 = n.forces?.P2 ?? 0;
          el.forces.textContent = `${p1}|${p2}`;
        }

        if (sliderIndex === 0) {
          turnLabel.textContent = "Start (before ply 0)";
          turnInfo.textContent = [
            "Initial state",
            `Active: ${frame.state.activePlayer}`,
            `Supply: P1=${frame.state.supplies?.P1 ?? "?"} P2=${frame.state.supplies?.P2 ?? "?"}`,
          ].join("\n");
          rationale.textContent = "—";
          actions.textContent = "—";
          events.textContent = "—";
          renderSelectedNode();
          return;
        }

        const t = frame.turn;
        const timeLabel = timeMode.value === "before" ? "Before" : "After";
        turnLabel.textContent = `Ply ${t.ply} (${t.player}) — ${timeLabel}`;

        const supplyLine = `Supply: P1=${frame.state.supplies?.P1 ?? "?"} P2=${frame.state.supplies?.P2 ?? "?"}`;
        const resultLine = `Result: ${replay.result.type === "win" ? `WIN ${replay.result.winner}` : "DRAW"}`;
        const note =
          timeMode.value === "after" && viewMode.value !== "Omni"
            ? "Note: After uses omniscient stateAfter (future POV-after not modeled yet)."
            : "";
        turnInfo.textContent = [turnLabel.textContent, supplyLine, resultLine, note].filter(Boolean).join("\n");

        rationale.textContent = t.rationaleText ?? "—";
        actions.textContent = JSON.stringify(t.actions, null, 2);
        events.textContent = JSON.stringify(t.events, null, 2);
        renderSelectedNode();
      }

      function setReplay(r) {
        replay = r;
        selectedNodeId = null;
        statusEl.textContent = `${replay.scenario.name} (${replay.turns.length} plies)`;
        slider.min = "0";
        slider.max = String(replay.turns.length);
        slider.value = "0";
        buildMap();
        render();
      }

      async function loadReplayFromFile(file) {
        const text = await file.text();
        setReplay(JSON.parse(text));
      }

      fileInput.addEventListener("change", async () => {
        const file = fileInput.files && fileInput.files[0];
        if (!file) return;
        try {
          await loadReplayFromFile(file);
        } catch (e) {
          statusEl.textContent = "Failed to load replay";
          console.error(e);
        }
      });

      for (const el of [slider, viewMode, timeMode]) {
        el.addEventListener("input", () => render());
      }

      prevBtn.addEventListener("click", () => {
        slider.value = String(clampIndex(Number.parseInt(slider.value, 10) - 1));
        render();
      });
      nextBtn.addEventListener("click", () => {
        slider.value = String(clampIndex(Number.parseInt(slider.value, 10) + 1));
        render();
      });

      document.addEventListener("keydown", (e) => {
        if (!replay) return;
        if (e.key === "ArrowLeft") prevBtn.click();
        if (e.key === "ArrowRight") nextBtn.click();
      });

      const mapWrap = document.getElementById("mapWrap");
      mapWrap.addEventListener("dragenter", (e) => {
        e.preventDefault();
        dropHint.style.display = "flex";
      });
      mapWrap.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropHint.style.display = "flex";
      });
      mapWrap.addEventListener("dragleave", () => {
        dropHint.style.display = "none";
      });
      mapWrap.addEventListener("drop", async (e) => {
        e.preventDefault();
        dropHint.style.display = "none";
        const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
        if (!file) return;
        try {
          await loadReplayFromFile(file);
        } catch (err) {
          statusEl.textContent = "Failed to load replay";
          console.error(err);
        }
      });
    </script>
  </body>
</html>

