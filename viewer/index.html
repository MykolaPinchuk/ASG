<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ASG Replay Viewer</title>
    <style>
      :root {
        --bg: #0b1020;
        --panel: #101a33;
        --text: #e8eefc;
        --muted: #9fb0d0;
        --p1: #4ea1ff;
        --p2: #ff5a73;
        --neutral: #8c97b2;
        --edge: rgba(232, 238, 252, 0.18);
        --border: rgba(232, 238, 252, 0.12);
        --hl-move: #8af0ff;
        --hl-combat: #ffb347;
        --hl-capture: #ffe066;
        --hl-reinforce: #7dff90;
        --hl-invalid: #ff6b6b;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        background: var(--bg);
        color: var(--text);
      }
      header {
        padding: 12px 16px;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      header h1 {
        margin: 0;
        font-size: 14px;
        font-weight: 650;
        letter-spacing: 0.02em;
        white-space: nowrap;
      }
      #controls {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
      }
      #controls label {
        font-size: 12px;
        color: var(--muted);
        margin-right: 6px;
      }
      #controls select,
      #controls input[type="file"],
      #controls button {
        font-size: 12px;
        color: var(--text);
      }
      button {
        background: rgba(232, 238, 252, 0.06);
        border: 1px solid rgba(232, 238, 252, 0.16);
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.5;
        cursor: default;
      }
      #layout {
        height: calc(100% - 54px);
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 12px;
        padding: 12px;
        box-sizing: border-box;
      }
      #mapWrap {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
      }
      #dropHint {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-size: 13px;
        border: 2px dashed rgba(232, 238, 252, 0.18);
        margin: 10px;
        border-radius: 10px;
        background: rgba(11, 16, 32, 0.35);
        pointer-events: none;
      }
      #map {
        width: 100%;
        height: 100%;
        display: block;
      }
      #side {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        overflow: auto;
      }
      .block {
        margin-bottom: 12px;
      }
      .block h2 {
        margin: 0 0 6px 0;
        font-size: 12px;
        color: var(--muted);
        font-weight: 650;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }
      pre {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        font-size: 12px;
        line-height: 1.35;
      }
      .help {
        font-size: 12px;
        line-height: 1.35;
        color: rgba(232, 238, 252, 0.92);
      }
      .help ul {
        margin: 6px 0 0 16px;
        padding: 0;
      }
      .help li {
        margin: 4px 0;
        color: rgba(232, 238, 252, 0.86);
      }
      .help code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 11px;
        color: rgba(232, 238, 252, 0.92);
        background: rgba(232, 238, 252, 0.06);
        border: 1px solid rgba(232, 238, 252, 0.12);
        padding: 1px 6px;
        border-radius: 999px;
        white-space: nowrap;
      }
      .pill {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 12px;
        border: 1px solid rgba(232, 238, 252, 0.16);
        color: var(--muted);
        white-space: nowrap;
      }
      .legendRow {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      .swatch {
        width: 10px;
        height: 10px;
        border-radius: 3px;
        border: 1px solid rgba(232, 238, 252, 0.22);
        display: inline-block;
        vertical-align: middle;
        margin-right: 6px;
      }
      .legendItem {
        display: inline-flex;
        align-items: center;
        font-size: 12px;
        color: rgba(232, 238, 252, 0.86);
      }
      .mapLegend {
        position: absolute;
        left: 12px;
        bottom: 12px;
        background: rgba(16, 26, 51, 0.9);
        border: 1px solid rgba(232, 238, 252, 0.12);
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 12px;
        color: rgba(232, 238, 252, 0.86);
        backdrop-filter: blur(6px);
      }
      .mapLegendTitle {
        font-size: 12px;
        font-weight: 650;
        color: rgba(232, 238, 252, 0.95);
        margin-bottom: 6px;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .row > * {
        flex: 0 0 auto;
      }
      .grow {
        flex: 1 1 auto;
        min-width: 260px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>ASG Replay Viewer</h1>
      <div id="controls">
        <input id="fileInput" type="file" accept="application/json" />
        <span class="pill" id="status">No replay loaded</span>
        <button id="helpBtn" title="Toggle explanation panel">Help</button>

        <div class="row">
          <label for="viewMode">View</label>
          <select id="viewMode">
            <option value="Omni">Omni</option>
            <option value="P1">P1 POV</option>
            <option value="P2">P2 POV</option>
            <option value="Diff">Diff</option>
          </select>
        </div>

        <div class="row">
          <label for="timeMode">State</label>
          <select id="timeMode">
            <option value="after">After</option>
            <option value="before">Before</option>
          </select>
        </div>

        <div class="row">
          <button id="prevBtn" title="Left arrow">Prev</button>
          <button id="nextBtn" title="Right arrow">Next</button>
        </div>

        <div class="grow">
          <input id="turnSlider" type="range" min="0" max="0" value="0" step="1" style="width: 100%" />
          <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--muted)">
            <span id="startLabel">Start</span>
            <span id="turnLabel">—</span>
            <span id="endLabel">End</span>
          </div>
        </div>
      </div>
    </header>

    <div id="layout">
      <div id="mapWrap">
        <div id="dropHint">Drop a replay JSON here</div>
        <div class="mapLegend" id="mapLegend" style="display: none">
          <div class="mapLegendTitle">Legend</div>
          <div class="legendRow">
            <span class="legendItem"><span class="swatch" style="background: var(--p1)"></span>P1 owns</span>
            <span class="legendItem"><span class="swatch" style="background: var(--p2)"></span>P2 owns</span>
            <span class="legendItem"><span class="swatch" style="background: var(--neutral)"></span>Neutral</span>
          </div>
          <div style="margin-top: 6px; color: rgba(232, 238, 252, 0.78)">
            Node text: <code>P1|P2</code> forces. <code>+2</code> is supply yield if owned.
          </div>
        </div>
        <svg id="map" viewBox="0 0 800 600"></svg>
      </div>
      <div id="side">
        <div class="block" id="helpBlock" style="display: none">
          <h2>How To Read This</h2>
          <div class="help">
            <div>
              A match is a sequence of <b>plies</b> (half-turns). Each ply: income happens first, then the active player submits
              up to <code>actionBudget</code> actions.
            </div>
            <ul>
              <li>
                Use the slider or <code>Prev</code>/<code>Next</code> to move through time. Slider <code>0</code> is the initial state.
              </li>
              <li><code>State=Before</code> shows right before that ply’s actions. <code>After</code> shows after resolution.</li>
              <li>
                Map nodes: color = owner, center text <code>P1|P2</code> = forces at that node. If a node shows <code>+2</code>, it
                produces +2 supply per ply for its owner.
              </li>
              <li>
                <b>Events</b> are the authoritative “what happened” log. Nodes involved in the current ply are highlighted on the map.
              </li>
              <li>
                Click a node to inspect it. In <code>View=Diff</code>, the node panel shows P1/P2/Omni side-by-side.
              </li>
            </ul>
          </div>
        </div>
        <div class="block">
          <h2>Turn</h2>
          <pre id="turnInfo">Load a replay JSON to begin.</pre>
        </div>
        <div class="block">
          <h2>Selected Node</h2>
          <pre id="nodeInfo">Click a node to inspect details.</pre>
        </div>
        <div class="block">
          <h2>Rationale</h2>
          <pre id="rationale">—</pre>
        </div>
        <div class="block">
          <h2>Actions</h2>
          <pre id="actions">—</pre>
        </div>
        <div class="block">
          <h2>Events</h2>
          <pre id="events">—</pre>
        </div>
      </div>
    </div>

    <script>
      /** @type {any | null} */
      let replay = null;
      /** @type {Record<string, any> | null} */
      let nodeEls = null;
      /** @type {Record<string, any> | null} */
      let nodePos = null;
      /** @type {string | null} */
      let selectedNodeId = null;

      const fileInput = document.getElementById("fileInput");
      const statusEl = document.getElementById("status");
      const slider = document.getElementById("turnSlider");
      const turnLabel = document.getElementById("turnLabel");
      const viewMode = document.getElementById("viewMode");
      const timeMode = document.getElementById("timeMode");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const dropHint = document.getElementById("dropHint");
      const helpBtn = document.getElementById("helpBtn");
      const helpBlock = document.getElementById("helpBlock");
      const mapLegend = document.getElementById("mapLegend");

      const turnInfo = document.getElementById("turnInfo");
      const nodeInfo = document.getElementById("nodeInfo");
      const rationale = document.getElementById("rationale");
      const actions = document.getElementById("actions");
      const events = document.getElementById("events");

      const svg = document.getElementById("map");

      function setHelpVisible(visible) {
        helpBlock.style.display = visible ? "block" : "none";
      }

      helpBtn.addEventListener("click", () => {
        const visible = helpBlock.style.display !== "none";
        setHelpVisible(!visible);
      });

      function ownerColor(owner) {
        const css = getComputedStyle(document.documentElement);
        if (owner === "P1") return css.getPropertyValue("--p1");
        if (owner === "P2") return css.getPropertyValue("--p2");
        return css.getPropertyValue("--neutral");
      }

      function clearSvg() {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
      }

      function computeInitialState(scenario) {
        const nodes = {};
        for (const nodeDef of scenario.map.nodes) {
          nodes[nodeDef.id] = {
            id: nodeDef.id,
            x: nodeDef.x,
            y: nodeDef.y,
            owner: nodeDef.owner,
            supplyYield: nodeDef.supplyYield,
            forces: { P1: 0, P2: 0 },
          };
        }

        const nodeForces = (scenario.initialState && scenario.initialState.nodeForces) || {};
        for (const [nodeId, forces] of Object.entries(nodeForces)) {
          if (!nodes[nodeId]) continue;
          nodes[nodeId].forces.P1 = (forces && forces.P1) || 0;
          nodes[nodeId].forces.P2 = (forces && forces.P2) || 0;
        }

        const playerSupply = (scenario.initialState && scenario.initialState.playerSupply) || {};
        return {
          scenarioId: scenario.id,
          ply: 0,
          activePlayer: scenario.startingPlayer,
          supplies: { P1: playerSupply.P1 || 0, P2: playerSupply.P2 || 0 },
          nodes,
        };
      }

      function buildMap() {
        clearSvg();
        nodeEls = {};
        nodePos = {};

        const nodes = replay.scenario.map.nodes;
        const edges = replay.scenario.map.edges;
        const p1Hq = replay.scenario.players && replay.scenario.players.P1 && replay.scenario.players.P1.hq;
        const p2Hq = replay.scenario.players && replay.scenario.players.P2 && replay.scenario.players.P2.hq;

        const xs = nodes.map((n) => n.x);
        const ys = nodes.map((n) => n.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        const pad = 60;

        const w = 800;
        const h = 600;
        const spanX = Math.max(1, maxX - minX);
        const spanY = Math.max(1, maxY - minY);
        const scale = Math.min((w - 2 * pad) / spanX, (h - 2 * pad) / spanY);

        const pos = (x, y) => {
          const sx = pad + (x - minX) * scale;
          const sy = pad + (maxY - y) * scale;
          return { x: sx, y: sy };
        };

        for (const n of nodes) nodePos[n.id] = pos(n.x, n.y);

        for (const [a, b] of edges) {
          const pa = nodePos[a];
          const pb = nodePos[b];
          if (!pa || !pb) continue;

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", pa.x);
          line.setAttribute("y1", pa.y);
          line.setAttribute("x2", pb.x);
          line.setAttribute("y2", pb.y);
          line.setAttribute("stroke", getComputedStyle(document.documentElement).getPropertyValue("--edge"));
          line.setAttribute("stroke-width", "2");
          svg.appendChild(line);
        }

        for (const n of nodes) {
          const p = nodePos[n.id];
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

          const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          circle.setAttribute("cx", p.x);
          circle.setAttribute("cy", p.y);
          circle.setAttribute("r", "18");
          circle.setAttribute("fill", ownerColor(n.owner));
          circle.setAttribute("stroke", "rgba(232,238,252,0.25)");
          circle.setAttribute("stroke-width", "2");
          circle.style.cursor = "pointer";
          circle.addEventListener("click", () => {
            selectedNodeId = n.id;
            renderSelectedNode();
          });
          g.appendChild(circle);

          const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
          label.setAttribute("x", p.x);
          label.setAttribute("y", p.y - 24);
          label.setAttribute("text-anchor", "middle");
          label.setAttribute("fill", "rgba(232,238,252,0.85)");
          label.setAttribute("font-size", "11");
          label.textContent = n.id;
          g.appendChild(label);

          const forces = document.createElementNS("http://www.w3.org/2000/svg", "text");
          forces.setAttribute("x", p.x);
          forces.setAttribute("y", p.y + 5);
          forces.setAttribute("text-anchor", "middle");
          forces.setAttribute("fill", "rgba(11,16,32,0.95)");
          forces.setAttribute("font-size", "12");
          forces.setAttribute("font-weight", "750");
          forces.textContent = "0|0";
          g.appendChild(forces);

          const yieldText = document.createElementNS("http://www.w3.org/2000/svg", "text");
          yieldText.setAttribute("x", p.x);
          yieldText.setAttribute("y", p.y + 26);
          yieldText.setAttribute("text-anchor", "middle");
          yieldText.setAttribute("fill", "rgba(232,238,252,0.7)");
          yieldText.setAttribute("font-size", "11");
          yieldText.textContent = n.supplyYield > 0 ? `+${n.supplyYield}` : "";
          g.appendChild(yieldText);

          if (n.id === p1Hq || n.id === p2Hq) {
            const hq = document.createElementNS("http://www.w3.org/2000/svg", "text");
            hq.setAttribute("x", p.x);
            hq.setAttribute("y", p.y + 44);
            hq.setAttribute("text-anchor", "middle");
            hq.setAttribute("fill", "rgba(232,238,252,0.75)");
            hq.setAttribute("font-size", "10");
            hq.setAttribute("font-weight", "650");
            hq.textContent = "HQ";
            g.appendChild(hq);
          }

          svg.appendChild(g);
          nodeEls[n.id] = { circle, forces, yieldText };
        }
      }

      function clampIndex(i) {
        if (!replay) return 0;
        return Math.max(0, Math.min(i, replay.turns.length));
      }

      function beforeStateForIndex(index) {
        if (!replay) return null;
        if (index <= 0) return computeInitialState(replay.scenario);
        return replay.turns[index - 1].stateAfter;
      }

      function afterStateForIndex(index) {
        if (!replay) return null;
        if (index < 0 || index >= replay.turns.length) return null;
        return replay.turns[index].stateAfter;
      }

      function getFrame(index) {
        if (!replay) return null;

        if (index === 0 && timeMode.value === "before") {
          const init = computeInitialState(replay.scenario);
          return { kind: "init", index, turn: replay.turns[0], state: init };
        }

        if (index <= 0) {
          const init = computeInitialState(replay.scenario);
          return { kind: "init", index: 0, turn: replay.turns[0], state: init };
        }

        const tIndex = index - 1;
        const turn = replay.turns[tIndex];
        if (!turn) return null;

        const vm = viewMode.value;
        const tm = timeMode.value;

        const beforeState = beforeStateForIndex(tIndex);
        const afterState = afterStateForIndex(tIndex);

        if (tm === "before") {
          if (vm === "P1") return { kind: "before", index: tIndex, turn, state: turn.observations.P1 };
          if (vm === "P2") return { kind: "before", index: tIndex, turn, state: turn.observations.P2 };
          // Omni/Diff "before" uses omniscient state-before (previous stateAfter / initial).
          return { kind: "before", index: tIndex, turn, state: beforeState };
        }

        // After: omniscient post-resolution state.
        return { kind: "after", index: tIndex, turn, state: afterState };
      }

      function updateButtons() {
        if (!replay) {
          prevBtn.disabled = true;
          nextBtn.disabled = true;
          return;
        }
        const idx = Number.parseInt(slider.value, 10);
        prevBtn.disabled = idx <= 0;
        nextBtn.disabled = idx >= replay.turns.length;
      }

      function formatAction(a) {
        if (!a) return "—";
        if (a.type === "pass") return "pass";
        if (a.type === "reinforce") return `reinforce +${a.amount} at HQ`;
        if (a.type === "move") return `move ${a.amount} ${a.from} → ${a.to}`;
        return JSON.stringify(a);
      }

      function formatEvent(e) {
        if (!e) return "—";
        switch (e.type) {
          case "income":
            return `income: ${e.player} +${e.amount} (supply now ${e.supplyAfter})`;
          case "invalid_action":
            return `invalid: ${e.player} ${formatAction(e.action)} — ${e.message}`;
          case "reinforce":
            return `reinforce: ${e.player} +${e.amount} at ${e.location} (supply ${e.supplyAfter}, strength now ${e.strengthAfter})`;
          case "move":
            return `move: ${e.player} ${e.amount} ${e.from} → ${e.to} (from=${e.fromStrengthAfter}, to=${e.toStrengthAfter})`;
          case "combat":
            return (
              `combat @${e.location}: ${e.attacker}(${e.attackerStrengthBefore}) vs ${e.defender}(${e.defenderStrengthBefore}) ` +
              `noise=${e.noise} Δ=${e.delta} winner=${e.winner}(${e.winnerStrengthAfter})`
            );
          case "capture":
            return `capture: ${e.location} → ${e.newOwner}`;
          case "game_end":
            return e.result.type === "win" ? `game end: WIN ${e.result.winner} (HQ captured)` : `game end: DRAW (turn cap)`;
          default:
            return JSON.stringify(e);
        }
      }

      function clearHighlights() {
        if (!nodeEls) return;
        for (const el of Object.values(nodeEls)) {
          el.circle.setAttribute("stroke", "rgba(232,238,252,0.25)");
          el.circle.setAttribute("stroke-width", "2");
        }
      }

      function highlightNode(id, color) {
        if (!nodeEls || !nodeEls[id]) return;
        nodeEls[id].circle.setAttribute("stroke", color);
        nodeEls[id].circle.setAttribute("stroke-width", "4");
      }

      function highlightFromEvents(turn) {
        clearHighlights();
        if (!turn || !Array.isArray(turn.events)) return;
        const css = getComputedStyle(document.documentElement);
        const colors = {
          move: css.getPropertyValue("--hl-move"),
          combat: css.getPropertyValue("--hl-combat"),
          capture: css.getPropertyValue("--hl-capture"),
          reinforce: css.getPropertyValue("--hl-reinforce"),
          invalid: css.getPropertyValue("--hl-invalid"),
        };

        for (const e of turn.events) {
          if (e.type === "move") {
            highlightNode(e.from, colors.move);
            highlightNode(e.to, colors.move);
          } else if (e.type === "combat") {
            highlightNode(e.location, colors.combat);
          } else if (e.type === "capture") {
            highlightNode(e.location, colors.capture);
          } else if (e.type === "reinforce") {
            highlightNode(e.location, colors.reinforce);
          } else if (e.type === "invalid_action") {
            const maybeMove = e.action && e.action.type === "move" ? e.action : null;
            if (maybeMove) {
              highlightNode(maybeMove.from, colors.invalid);
              highlightNode(maybeMove.to, colors.invalid);
            }
          }
        }
      }

      function renderSelectedNode() {
        if (!replay || !selectedNodeId) return;

        const sliderIndex = Number.parseInt(slider.value, 10) - 1;
        const turn = replay.turns[Math.max(0, sliderIndex)];
        const tm = timeMode.value;
        const vm = viewMode.value;

        const beforeOmni = sliderIndex < 0 ? computeInitialState(replay.scenario) : beforeStateForIndex(sliderIndex);
        const afterOmni = sliderIndex < 0 ? null : afterStateForIndex(sliderIndex);

        const p1 = turn?.observations?.P1?.nodes?.[selectedNodeId];
        const p2 = turn?.observations?.P2?.nodes?.[selectedNodeId];
        const omni = tm === "before" ? beforeOmni?.nodes?.[selectedNodeId] : afterOmni?.nodes?.[selectedNodeId];

        function fmt(label, n) {
          if (!n) return `${label}: (missing)`;
          const f1 = n.forces?.P1 ?? "?";
          const f2 = n.forces?.P2 ?? "?";
          return `${label}: owner=${n.owner} forces=P1:${f1} P2:${f2} yield=${n.supplyYield}`;
        }

        const lines = [];
        lines.push(`node: ${selectedNodeId}`);
        lines.push(`meaning: node color = owner; center text P1|P2 = forces; +N = supply yield`);
        if (vm === "Diff") {
          lines.push(fmt("P1 sees", p1));
          lines.push(fmt("P2 sees", p2));
          lines.push(fmt("Omni", omni));
        } else if (vm === "P1") {
          lines.push(fmt("P1 sees", p1));
          lines.push(fmt("Omni", omni));
        } else if (vm === "P2") {
          lines.push(fmt("P2 sees", p2));
          lines.push(fmt("Omni", omni));
        } else {
          lines.push(fmt("Omni", omni));
        }
        nodeInfo.textContent = lines.join("\n");
      }

      function render() {
        const sliderIndex = Number.parseInt(slider.value, 10);
        const frame = getFrame(sliderIndex);
        updateButtons();

        if (!frame || !frame.state || !nodeEls) return;

        const nodes = frame.state.nodes;
        for (const [id, el] of Object.entries(nodeEls)) {
          const n = nodes[id];
          if (!n) continue;
          el.circle.setAttribute("fill", ownerColor(n.owner));
          const p1 = n.forces?.P1 ?? 0;
          const p2 = n.forces?.P2 ?? 0;
          el.forces.textContent = `${p1}|${p2}`;
        }

        if (sliderIndex === 0) {
          turnLabel.textContent = "Start (before ply 0)";
          turnInfo.textContent = [
            "Initial state",
            `Active: ${frame.state.activePlayer}`,
            `Supply: P1=${frame.state.supplies?.P1 ?? "?"} P2=${frame.state.supplies?.P2 ?? "?"}`,
            `Settings: actionBudget=${replay.scenario.settings.actionBudget}, baseIncome=${replay.scenario.settings.baseIncome}, turnCapPlies=${replay.scenario.settings.turnCapPlies}`,
          ].join("\n");
          rationale.textContent = "—";
          actions.textContent = "—";
          events.textContent = "—";
          clearHighlights();
          renderSelectedNode();
          return;
        }

        const t = frame.turn;
        const timeLabel = timeMode.value === "before" ? "Before" : "After";
        turnLabel.textContent = `Ply ${t.ply} (${t.player}) — ${timeLabel}`;

        const supplyLine = `Supply: P1=${frame.state.supplies?.P1 ?? "?"} P2=${frame.state.supplies?.P2 ?? "?"}`;
        const resultLine = `Result: ${replay.result.type === "win" ? `WIN ${replay.result.winner}` : "DRAW"}`;
        const note =
          timeMode.value === "after" && viewMode.value !== "Omni"
            ? "Note: After uses omniscient stateAfter (future POV-after not modeled yet)."
            : "";
        turnInfo.textContent = [turnLabel.textContent, supplyLine, resultLine, note].filter(Boolean).join("\n");

        rationale.textContent = t.rationaleText ?? "—";
        actions.textContent =
          Array.isArray(t.actions) && t.actions.length > 0 ? t.actions.map((a, i) => `${i + 1}. ${formatAction(a)}`).join("\n") : "—";
        events.textContent =
          Array.isArray(t.events) && t.events.length > 0 ? t.events.map((e) => `- ${formatEvent(e)}`).join("\n") : "—";
        highlightFromEvents(t);
        renderSelectedNode();
      }

      function setReplay(r) {
        replay = r;
        selectedNodeId = null;
        statusEl.textContent = `${replay.scenario.name} (${replay.turns.length} plies)`;
        mapLegend.style.display = "block";
        setHelpVisible(true);
        slider.min = "0";
        slider.max = String(replay.turns.length);
        slider.value = "0";
        buildMap();
        render();
      }

      async function loadReplayFromFile(file) {
        const text = await file.text();
        setReplay(JSON.parse(text));
      }

      fileInput.addEventListener("change", async () => {
        const file = fileInput.files && fileInput.files[0];
        if (!file) return;
        try {
          await loadReplayFromFile(file);
        } catch (e) {
          statusEl.textContent = "Failed to load replay";
          console.error(e);
        }
      });

      for (const el of [slider, viewMode, timeMode]) {
        el.addEventListener("input", () => render());
      }

      prevBtn.addEventListener("click", () => {
        slider.value = String(clampIndex(Number.parseInt(slider.value, 10) - 1));
        render();
      });
      nextBtn.addEventListener("click", () => {
        slider.value = String(clampIndex(Number.parseInt(slider.value, 10) + 1));
        render();
      });

      document.addEventListener("keydown", (e) => {
        if (!replay) return;
        if (e.key === "ArrowLeft") prevBtn.click();
        if (e.key === "ArrowRight") nextBtn.click();
      });

      const mapWrap = document.getElementById("mapWrap");
      mapWrap.addEventListener("dragenter", (e) => {
        e.preventDefault();
        dropHint.style.display = "flex";
      });
      mapWrap.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropHint.style.display = "flex";
      });
      mapWrap.addEventListener("dragleave", () => {
        dropHint.style.display = "none";
      });
      mapWrap.addEventListener("drop", async (e) => {
        e.preventDefault();
        dropHint.style.display = "none";
        const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
        if (!file) return;
        try {
          await loadReplayFromFile(file);
        } catch (err) {
          statusEl.textContent = "Failed to load replay";
          console.error(err);
        }
      });
    </script>
  </body>
</html>
